
module GV_FSM
  module Templates
    HEADER =<<~EOHEADER
      // Finite State Machine
      // Project: <%= self.project_name or self.dotfile %>
      // Description: <%= self.description or "<none given>" %>
      //
      // Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
      // gv_fsm version <%= GV_FSM::VERSION %>
      // Generation date: <%= Time.now %>
      // Generated from: <%= self.dotfile %>
      // The finite state machine has:
      //   <%= self.states.count %> states
      //   <%= self.transitions.count %> transitions

    EOHEADER

    HH =<<~EOH
      #ifndef <%= self.cname.upcase %>_H
      #define <%= self.cname.upcase %>_H
      #include <stdlib.h>

      // List of states
      typedef enum {
      <% self.states.each_with_index do |s, i| %>
        STATE_<%= s[:id].upcase %><%= i == 0 ? " = 0" : "" %>,  
      <% end %>
        NUM_STATES,
        NO_CHANGE
      } state_t;

      const char *state_names[] = {<%= self.states_list.map {|sn| '"'+sn+'"'}.join(", ") %>};

      // State function and state transition prototypes
      typedef state_t state_func_t(void *data);
      typedef void transition_func_t(void *data);

      // state functions
      <% self.states.each do |s| %>
      state_t <%= s[:function] %>(void *data);
      <% end %>

      // transition functions
      <% self.transition_functions_list.each do |t| %>
      <% next if t == "NULL" %>
      void <%= t %>(void *data);
      <% end %>

      // List of state functions
      state_func_t *const state_table[NUM_STATES] = {
        <%= self.state_functions_list.join(",\n  ")%>
      };

      // Table of transition functions
      transition_func_t *const transition_table[NUM_STATES][NUM_STATES] = {
      <% sl = self.states_list %>
      <% fw = self.transition_functions_list.max {|a, b| a.length <=> b.length}.length %>
      <% sw = self.states_list.max {|a, b| a.length <=> b.length}.length %>
        /* <%= "states:".ljust(sw) %>     <%= sl.map {|e| e.ljust(fw) }.join(", ") %> */
      <% self.transitions_map.each_with_index do |l, i| %>
        /* <%= sl[i].ljust(sw) %> */ {<%= l.map {|e| e.ljust(fw)}.join(", ") %>}, 
      <% end %>
      };

      // state manager
      state_t run_state(state_t cur_state, void *data);
      
      #endif
    EOH

    CC =<<~EOC
      #include <syslog.h>
      #include "<%= self.cname %>.h"
      
      // State functions
      <% dest = self.destinations.dup %>
      <% self.states.each do |s| %>
      <% stable = true if dest[s[:id]].include? s[:id] %>
      <% dest[s[:id]].map! {|n| "STATE_"+n.upcase} %>
      <% if dest[s[:id]].empty? or stable then
        dest[s[:id]].unshift "NO_CHANGE"
      end %>
      state_t <%= s[:function] %>(void *data) {
        state_t next_state = <%= dest[s[:id]].first %>;

        syslog(LOG_INFO, "[FSM] In state <%= s[:id] %>");
        /* Your code here */
        
        // valid return states: <%= dest[s[:id]].join(", ") %>
        switch (next_state) {
      <% dest[s[:id]].each  do |str| %>
          case <%= str %>:
      <% end %>
            break;
          default:
            syslog(LOG_WARNING, "[FSM] Cannot pass from <%= s[:id] %> to %s, remaining in this state", state_names[next_state]);
            next_state = NO_CHANGE;
        }
        return next_state;
      }

      <% end %>

      // Transition functions
      <% self.transition_functions_list.each do |t| %>
      <% next if t == "NULL" %>
      void <%= t %>(void *data) {
        syslog(LOG_INFO, "[FSM] State transition <%= t %>");
        /* Your code here */
      }

      <% end %>

      // State manager
      state_t run_state(state_t cur_state, void *data) {
        state_t new_state = state_table[cur_state](data);
        transition_func_t *transition = transition_table[cur_state][new_state];
        if (transition)
          transition(data);
        return new_state == NO_CHANGE ? cur_state : new_state;
      };


      #ifdef TEST_MAIN
      #include <unistd.h>
      int main() {
        state_t cur_state = STATE_INIT;
        openlog("SM", LOG_PID | LOG_PERROR, LOG_USER);
        syslog(LOG_INFO, "Starting SM");
        do {
          cur_state = run_state(cur_state, NULL);
          sleep(1);
        } while (cur_state != STATE_STOP);
        return 0;
      }
      #endif
    EOC
  end
end